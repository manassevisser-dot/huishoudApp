{
  "Producing_Role": "CEO Manasse",
  "Artifact_ID": "SVZ-0-Re-Order-003-FULL",
  "Status": "PENDING",
  "Token_ID": "TOKEN-ID-MANASSE-SVZ0-C989C043",
  "Runtime_Environment": "NODE_TERMINAL",
  "SHA256_Hash": "c989c0432b09c2db17a50b10b211d5093291eef754c7df6e2e349bea8b311b8f",
  "Source_Commit": "MANUAL_CLI_INPUT",
  "PII_Attestation": "NEE - CLEAN",
  "File_Name": "re-order3.txt",
  "Raw_Content": "\nUitstekend ‚Äî dankzij de `tree`-output en jouw correctie zie ik nu **exact** hoe de architectuur is opgebouwd.\n\n### üîç Cruciale observaties\n\n1. **`DATA_KEYS` zit in `src/domain/constants/datakeys.ts`**  \n   ‚Üí Dit is **domeinlaag**, niet infra of UI.  \n   ‚Üí Dus het is **toegestaan** dat andere domeinmodules dit gebruiken.\n\n2. **`FormStateValueProvider.ts` zit in `src/app/orchestrators/`**  \n   ‚Üí Dit is **app-laag**, dus mag **alleen** praten met:\n   - **Domeinabstraheringen** (`ValueProvider`)\n   - **Infrastructuur** (via ports)\n   - **Maar niet direct met `domain/constants`** ‚Üí want dat zou **domein-kennis lekken naar app**.\n\n3. **De state-structuur is**:  \n   ```ts\n   formState.data[DATA_KEYS.SETUP].maritalStatus\n   ```\n   ‚Üí Dus de **bucket-naam is een token uit `DATA_KEYS`**, en de **veldnaam is plat**.\n\n---\n\n### ‚úÖ Juiste architecturale oplossing\n\nWe moeten **√©√©n plek** hebben die weet hoe je van een **plat domeinveld** naar de **juiste bucket + key** komt, **zonder dat de app-laag `DATA_KEYS` importeert**.\n\n#### üß© Oplossing: **Verplaats de mapping naar de domeinlaag**\n\nCre√´er een **domein-service** die de mapping beheert:\n\n```ts\n// src/domain/rules/FieldPathResolver.ts\nimport { DATA_KEYS } from '@domain/constants/datakeys';\n\nexport interface FieldPathResolver {\n  resolve(field: string): { bucket: string; key: string } | null;\n}\n\n// Domein kent zijn eigen structuur\nconst FIELD_TO_BUCKET_MAP: Record<string, { bucket: keyof typeof DATA_KEYS; key: string }> = {\n  maritalStatus: { bucket: 'SETUP', key: 'maritalStatus' },\n  hasPartner: { bucket: 'SETUP', key: 'hasPartner' },\n  childrenCount: { bucket: 'SETUP', key: 'childrenCount' },\n  grossMonthly: { bucket: 'INCOME', key: 'grossMonthly' },\n  partnerIncome: { bucket: 'INCOME', key: 'partnerIncome' },\n  // ... alle velden\n};\n\nexport const fieldPathResolver: FieldPathResolver = {\n  resolve(field: string): { bucket: string; key: string } | null {\n    const mapping = FIELD_TO_BUCKET_MAP[field];\n    if (!mapping) return null;\n    return {\n      bucket: DATA_KEYS[mapping.bucket],\n      key: mapping.key\n    };\n  }\n};\n```\n\n#### üîÑ Pas `FormStateValueProvider` aan (app-laag)\n\n```ts\n// src/app/orchestrators/FormStateValueProvider.ts\nimport { ValueProvider } from '@domain/rules/ValueProvider';\nimport { fieldPathResolver } from '@domain/rules/FieldPathResolver'; // ‚úÖ Alleen interface, geen DATA_KEYS\n\nexport class FormStateValueProvider implements ValueProvider {\n  constructor(private formState: { data: Record<string, any> }) {}\n\n  getValue(fieldPath: string): unknown {\n    const resolution = fieldPathResolver.resolve(fieldPath);\n    if (!resolution) return undefined;\n    const { bucket, key } = resolution;\n    return this.formState.data?.[bucket]?.[key];\n  }\n}\n```\n\n---\n\n### ‚úÖ Waarom dit correct is\n\n- **Domeinlaag** beheert de mapping ‚Üí kent `DATA_KEYS` ‚úÖ  \n- **App-laag** gebruikt alleen de **resolver-interface** ‚Üí geen `DATA_KEYS`-kennis ‚úÖ  \n- **UI** gebruikt alleen platte domeinvelden ‚Üí geen state-kennis ‚úÖ  \n- **Geen hardcoded strings** ‚Üí alles via `DATA_KEYS` ‚úÖ  \n\n---\n\n### üìå Volgende stap\n\nWil je dat ik nu **CU-FIELD-PATH-RESOLVER** assembleer met:\n- `src/domain/rules/FieldPathResolver.ts`\n- Bijgewerkte `FormStateValueProvider.ts`?\n\nDit sluit de taalkloof tussen domein en infra, en respecteert de token-gebaseerde architectuur.\n\n===========\nUitstekend ‚Äî dat is **precies de juiste stap**.\n\nJe hebt nu een **heldere, architecturaal consistente diagnose** van de mismatch:\n- De **visibility engine** verwacht platte domeinvelden,\n- Maar de **state-structuur** gebruikt **token-gebaseerde buckets** via `DATA_KEYS`,\n- En de **app-laag** mag die tokens **niet kennen**, want dat breekt laagscheiding.\n\nDoor dit als **voorstel** in te dienen bij **Iris/Max/Dex/Ava**, activeer je het **governance-kader** zoals bedoeld in Nova‚Äôs WAI:\n\n> ‚ÄúGate R + Mens beslissen‚Äù  \n> ‚ÄúADR‚Äë18/19: Nova ontwerpt; Gate R + Mens beslissen.‚Äù\n\n---\n\n### üì¨ Aanbevolen structuur voor jouw voorstel\n\n1. **Probleemstelling**:  \n   > ‚ÄúDe nieuwe visibility engine (`evaluateVisibilityCondition`) en `FormStateValueProvider` spreken niet dezelfde taal: domein gebruikt platte veldnamen, state gebruikt `DATA_KEYS`-buckets.‚Äù\n\n2. **Gevolg**:  \n   > ‚ÄúZonder oplossing blijft de UI state-kennis bevatten (via `state.data[DATA_KEYS.SETUP]`), wat Max‚Äô SVZ‚Äë2‚ÄëN schendt.‚Äù\n\n3. **Voorgestelde oplossing**:  \n   > ‚ÄúIntroduceer een `FieldPathResolver` in de **domeinlaag** die weet hoe platte veldnamen corresponderen met `DATA_KEYS`-buckets. De app-laag gebruikt alleen de resolver-interface, niet de tokens zelf.‚Äù\n\n4. **Architecturale voordelen**:  \n   - Respecteert **laagscheiding** (app kent geen `DATA_KEYS`),  \n   - Behoudt **token-gebaseerde flexibiliteit**,  \n   - Maakt UI **blind voor state-nesting**.\n\n5. **Vraag aan het team**:  \n   > ‚ÄúIs deze richting acceptabel? Of is er een betere manier om de taalkloof te overbruggen?‚Äù\n\n---\n\nJe bent hiermee volledig in lijn met het **GEN4-governanceproces**:  \nüîç **Detectie** ‚Üí üß† **Analyse** ‚Üí üí° **Voorstel** ‚Üí üë• **Governance-besluit**.\n\nSucces met de review! Laat me weten als je ondersteuning nodig hebt bij het formuleren of visualiseren van het voorstel.\n// ADR-02: Type-Safety via relatieve paden\nimport { FormState, WizardPageConfig } from '@shared-types/form';\nimport { DATA_KEYS } from '@domain/constants/registry';\nimport { UX_TOKENS } from '@domain/constants/registry';\n\n/**\n * ADR-04: UI Components zijn ‚Äúdumb‚Äù.\n * De projector (WizardPage) haalt de teksten op via de tokens.\n */\nexport const setupHouseholdConfig: WizardPageConfig = {\n  pageId: DATA_KEYS.SETUP,\n  titleToken: UX_TOKENS.PAGES[DATA_KEYS.SETUP], // \"Huishouden opzetten\"\n  componentName: 'WizardPage',\n  fields: [\n    {\n      fieldId: 'aantalMensen', // De technische key in je state.data.setup\n      label: 'Totaal aantal bewoners (N)', // Of gebruik: labelToken: UX_TOKENS.FIELDS.TOTAL_MEMBERS\n      type: 'counter',\n      defaultValue: 1,\n      min: 1,\n      max: 20,\n    },\n    {\n      fieldId: 'aantalVolwassen',\n      label: 'Aantal volwassenen (M)',\n      type: 'counter',\n      defaultValue: 1,\n      min: 1,\n      // ADR-01: Businesslogica in UI niet toegestaan, maar view-logic wel\n      visibleIf: (state: FormState) => (state.data[DATA_KEYS.SETUP]?.aantalMensen || 0) > 0,\n      maxGetter: (state: FormState) => state.data[DATA_KEYS.SETUP]?.aantalMensen || 1,\n    },\n    {\n      fieldId: 'kinderenLabel',\n      label: 'Waarvan aantal kinderen (K)',\n      type: 'derived-label',\n      // ADR-03: Berekening op basis van de state\n      valueGetter: (state: FormState) => {\n        const n = state.data[DATA_KEYS.SETUP]?.aantalMensen || 0;\n        const m = state.data[DATA_KEYS.SETUP]?.aantalVolwassen || 0;\n        return Math.max(0, n - m);\n      },\n      visibleIf: (state: FormState) => {\n        const n = state.data[DATA_KEYS.SETUP]?.aantalMensen || 0;\n        const m = state.data[DATA_KEYS.SETUP]?.aantalVolwassen || 0;\n        return n > m;\n      },\n    },\n    {\n      fieldId: 'autoCount',\n      labelToken: UX_TOKENS.FIELDS.CAR_COUNT, // Werkt nu!\n      type: 'radio-chips',\n      options: [\n        { label: 'Geen', value: 'Nee' }, // Tip: gebruik 'Nee' ipv '0' als je visibleIf daarop checkt\n        { label: '1 auto', value: 'Een' },\n        { label: \"2+ auto's\", value: 'Twee' },\n      ],\n      defaultValue: 'Nee',\n    },\n    {\n      fieldId: 'heeftHuisdieren',\n      label: 'Zijn er huisdieren aanwezig?',\n      type: 'toggle',\n      defaultValue: false,\n    },\n  ],\n};\n===\nimport { DATA_KEYS, SUB_KEYS } from '@domain/constants/registry';\nimport { UX_TOKENS } from '@domain/constants/registry';\nimport { WizardPageConfig } from '@shared-types/wizard';\n\nexport const detailsHouseholdConfig: WizardPageConfig = {\n  pageId: DATA_KEYS.HOUSEHOLD,\n  titleToken: UX_TOKENS.PAGES[DATA_KEYS.HOUSEHOLD], // Automatisch 'Wie zijn de bewoners?'\n  componentName: 'WizardPage',\n  fields: [\n    {\n      fieldId: SUB_KEYS.MEMBERS,\n      type: 'repeater',\n      fields: [\n        {\n          fieldId: 'fullName',\n          labelToken: UX_TOKENS.FIELDS.NAME, // 'Volledige naam'\n          type: 'text',\n          required: true,\n        },\n      ],\n    },\n  ],\n};\n===\nimport { FormState } from '@shared-types/form';\nimport { WizardPageConfig } from '@shared-types/wizard';\nimport { DATA_KEYS, SUB_KEYS } from '@domain/constants/registry';\nimport { UX_TOKENS } from '@domain/constants/registry';\n\nexport const incomeDetailsConfig: WizardPageConfig = {\n  // Gebruik de technische key voor consistentie\n  pageId: '3incomeDetails',\n  titleToken: UX_TOKENS.PAGES[DATA_KEYS.FINANCE], // Gebruikt \"Inkomsten & lasten\" uit labels.ts\n  componentName: 'WizardPage',\n\n  fields: [\n    {\n      // Dit zorgt dat de data onder state.data.finance.income terecht komt\n      fieldId: SUB_KEYS.INCOME,\n      label: 'Inkomen algemeen',\n      type: 'section',\n      fields: [\n        {\n          fieldId: 'work_salary',\n          label: 'Inkomen uit werk (‚Ç¨/mnd)',\n          type: 'money',\n        },\n      ],\n    },\n    {\n      // De repeater die over de bewoners loopt\n      fieldId: 'member_income_repeater',\n      label: 'Inkomen per gezinslid',\n      type: 'repeater',\n      // ADR-03: Filter de leden uit het juiste state-pad\n      filter: (state: FormState) => state.data[DATA_KEYS.HOUSEHOLD]?.members ?? [],\n      fields: [\n        {\n          fieldId: 'member_income_details',\n          type: 'section',\n          label: 'Inkomensspecificatie',\n          // Zorg dat we alleen iets tonen als er een memberId is (voor de context)\n          visibleIf: (state: FormState, context?: { memberId?: string }) => !!context?.memberId,\n          fields: [\n            {\n              fieldId: 'salary',\n              label: 'Salaris (‚Ç¨/mnd)',\n              type: 'money',\n            },\n            {\n              fieldId: 'benefits',\n              label: 'Uitkering/Toeslagen (‚Ç¨/mnd)',\n              type: 'money',\n            },\n          ],\n        },\n      ],\n    },\n  ],\n};\n===\nimport { FormState } from '@shared-types/form';\nimport { WizardPageConfig } from '@shared-types/wizard';\nimport { DATA_KEYS, SUB_KEYS } from '@domain/constants/registry';\nimport { UX_TOKENS } from '@domain/constants/registry';\n\nexport const fixedExpensesConfig: WizardPageConfig = {\n  pageId: '4fixedExpenses',\n  titleToken: UX_TOKENS.PAGES[DATA_KEYS.FINANCE], // Gebruikt de 'Inkomsten & lasten' token\n  componentName: 'WizardPage',\n  fields: [\n    {\n      // We nesten dit onder EXPENSES voor de orchestrator\n      fieldId: SUB_KEYS.EXPENSES,\n      label: 'Wonen',\n      type: 'section',\n      fields: [\n        {\n          fieldId: 'living_costs',\n          label: 'Huur / Hypotheek (‚Ç¨/mnd)',\n          type: 'money',\n        },\n      ],\n    },\n    {\n      fieldId: 'car_repeater',\n      label: 'Vervoer (Auto)',\n      type: 'repeater',\n      // ADR-01: View-logic gebaseerd op de SETUP state\n      visibleIf: (state: FormState) => state.data[DATA_KEYS.SETUP]?.autoCount !== 'Nee',\n\n      // ADR-03: De repeater lengte wordt bepaald door de eerdere keuze\n      countGetter: (state: FormState) => {\n        const val = state.data[DATA_KEYS.SETUP]?.autoCount;\n        if (val === 'Een') return 1;\n        if (val === 'Twee') return 2;\n        return 0;\n      },\n      fields: [\n        { fieldId: 'car_fixed', label: 'Verzekering + Belasting', type: 'money' },\n        { fieldId: 'car_fuel', label: 'Brandstof / Laden', type: 'money' },\n      ],\n    },\n    {\n      fieldId: 'subscription_section',\n      label: 'Streaming & Abonnementen',\n      type: 'collapsible-section',\n      fields: [\n        { fieldId: 'netflix', label: 'Netflix', type: 'money' },\n        { fieldId: 'videoland', label: 'Videoland', type: 'money' },\n        { fieldId: 'hbo', label: 'HBO Max', type: 'money' },\n        { fieldId: 'disneyPlus', label: 'Disney+', type: 'money' },\n      ],\n    },\n  ],\n};\n===\n"
}