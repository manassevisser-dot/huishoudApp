===== FILE: src/ui/components/FieldRenderer.tsx =====
import React from 'react';
import { View, Text } from 'react-native';
import type { ValueProvider } from '@domain';
import { useAppStyles } from '@styles/useAppStyles';

interface FieldRendererProps {
  fieldId: string;
  valueProvider: ValueProvider;
}

export const FieldRenderer: React.FC<FieldRendererProps> = ({
  fieldId,
  valueProvider,
}) => {
  const { styles } = useAppStyles();
  const value = valueProvider.getValue(fieldId as any);

  return (
    // 'fieldContainer' komt uit Forms.ts (bewezen in vorige stap)
    <View style={styles.fieldContainer}>
      {/* 'description' komt uit Typography.ts (bewezen in deze stap) */}
      <Text style={styles.description}>
        {String(value ?? '')}
      </Text>
    </View>
  );
};


===== FILE: src/ui/components/__tests__/MoneyInput.test.tsx =====
import * as React from 'react';
import { render, fireEvent } from '@testing-library/react-native';
import MoneyInput from '../../../ui/components/fields/MoneyInput';
import { formatCentsToDutch, formatDutchValue, toCents } from '@app/orchestrators/types';
import { ThemeProvider } from '../../../app/context/ThemeContext';

// jest.Mock de utility functies
jest.mock('@app/orchestrators/types', () => ({
  formatCentsToDutch: jest.fn((cents: number) => {
    const euros = cents / 100;
    return euros.toFixed(2).replace('.', ',');
  }),
  formatDutchValue: jest.fn((value: string) => {
    return value.replace(/[^0-9,]/g, '');
  }),
  toCents: jest.fn((value: string) => {
    const cleaned = value.replace(',', '.');
    return Math.round(parseFloat(cleaned || '0') * 100);
  }),
}));

// jest.Mock useAppStyles
jest.mock('@ui/styles/useAppStyles', () => ({
  useAppStyles: () => ({
    styles: {
      inputMoneyRow: {},
      moneyPrefix: {},
      moneyTextInput: {},
    },
  }),
}));

// Wrapper component met ThemeProvider
const TestWrapper: React.FC<{ children: React.ReactNode }> = ({ children }) => (
  <ThemeProvider>{children}</ThemeProvider>
);

describe('MoneyInput', () => {
  const mockOnValueChange = jest.fn();

  beforeEach(() => {
    mockOnValueChange.mockClear();
    jest.clearAllMocks();
  });

  const renderWithTheme = (ui: React.ReactElement) => {
    return render(ui, { wrapper: TestWrapper });
  };

  describe('initial rendering', () => {
    test('renders with initial cents value formatted', () => {
      const { getByDisplayValue } = renderWithTheme(
        <MoneyInput value={12345} onValueChange={mockOnValueChange} />,
      );

      expect(formatCentsToDutch).toHaveBeenCalledWith(12345);
      expect(getByDisplayValue('123,45')).toBeTruthy();
    });

    test('renders with zero value', () => {
      const { getByDisplayValue } = renderWithTheme(
        <MoneyInput value={0} onValueChange={mockOnValueChange} />,
      );

      expect(formatCentsToDutch).toHaveBeenCalledWith(0);
      expect(getByDisplayValue('0,00')).toBeTruthy();
    });

    test('renders euro prefix', () => {
      const { getByText } = renderWithTheme(
        <MoneyInput value={5000} onValueChange={mockOnValueChange} />,
      );

      expect(getByText('€')).toBeTruthy();
    });

    test('renders with placeholder', () => {
      const { getByPlaceholderText } = renderWithTheme(
        <MoneyInput value={0} onValueChange={mockOnValueChange} placeholder="Voer bedrag in" />,
      );

      expect(getByPlaceholderText('Voer bedrag in')).toBeTruthy();
    });
  });

  describe('value synchronization', () => {
    test('updates local value when external value changes', () => {
      const { rerender, getByDisplayValue } = renderWithTheme(
        <MoneyInput value={10000} onValueChange={mockOnValueChange} />,
      );

      expect(getByDisplayValue('100,00')).toBeTruthy();

      rerender(
        <TestWrapper>
          <MoneyInput value={25000} onValueChange={mockOnValueChange} />
        </TestWrapper>,
      );

      expect(formatCentsToDutch).toHaveBeenCalledWith(25000);
      expect(getByDisplayValue('250,00')).toBeTruthy();
    });

    test('useEffect runs when value prop changes', () => {
      const { rerender } = renderWithTheme(
        <MoneyInput value={10000} onValueChange={mockOnValueChange} />,
      );

      // Clear mock calls after initial render
      (formatCentsToDutch as jest.Mock).mockClear();

      // Rerender with same value - useEffect should run because value prop exists in dependency array
      rerender(
        <TestWrapper>
          <MoneyInput value={10000} onValueChange={mockOnValueChange} />
        </TestWrapper>,
      );

      // useEffect will run on rerender even with same value (React behavior)
      expect(formatCentsToDutch).toHaveBeenCalled();
    });
  });

  describe('focus behavior', () => {
    test('removes thousand separators on focus', () => {
      const { getByDisplayValue } = renderWithTheme(
        <MoneyInput value={123456} onValueChange={mockOnValueChange} />,
      );

      const input = getByDisplayValue('1234,56');
      fireEvent(input, 'focus');

      expect(formatDutchValue).toHaveBeenCalled();
    });

    test('onFocus is called', () => {
      const { getByDisplayValue } = renderWithTheme(
        <MoneyInput value={5000} onValueChange={mockOnValueChange} />,
      );

      const input = getByDisplayValue('50,00');

      fireEvent(input, 'focus');

      expect(formatDutchValue).toHaveBeenCalled();
    });
  });

  describe('text input changes', () => {
    test('sanitizes input during typing', () => {
      const { getByDisplayValue } = renderWithTheme(
        <MoneyInput value={0} onValueChange={mockOnValueChange} />,
      );

      const input = getByDisplayValue('0,00');

      fireEvent.changeText(input, '123,45');

      expect(formatDutchValue).toHaveBeenCalledWith('123,45');
    });

    test('blocks invalid characters during typing', () => {
      const { getByDisplayValue } = renderWithTheme(
        <MoneyInput value={0} onValueChange={mockOnValueChange} />,
      );

      const input = getByDisplayValue('0,00');

      fireEvent.changeText(input, 'abc123');

      expect(formatDutchValue).toHaveBeenCalledWith('abc123');
    });

    test('allows decimal comma', () => {
      const { getByDisplayValue } = renderWithTheme(
        <MoneyInput value={0} onValueChange={mockOnValueChange} />,
      );

      const input = getByDisplayValue('0,00');

      fireEvent.changeText(input, '99,99');

      expect(formatDutchValue).toHaveBeenCalledWith('99,99');
    });
  });

  describe('blur behavior', () => {
    test('converts to cents and emits on blur', () => {
      const { getByDisplayValue } = renderWithTheme(
        <MoneyInput value={0} onValueChange={mockOnValueChange} />,
      );

      const input = getByDisplayValue('0,00');

      fireEvent.changeText(input, '50,00');
      fireEvent(input, 'blur');

      expect(toCents).toHaveBeenCalled();
      expect(mockOnValueChange).toHaveBeenCalled();
    });

    test('formats to Dutch standard on blur', () => {
      (toCents as jest.Mock).mockReturnValueOnce(12345);

      const { getByDisplayValue } = renderWithTheme(
        <MoneyInput value={0} onValueChange={mockOnValueChange} />,
      );

      const input = getByDisplayValue('0,00');

      fireEvent.changeText(input, '123,45');
      fireEvent(input, 'blur');

      expect(formatCentsToDutch).toHaveBeenCalledWith(12345);
    });

    test('handles empty input on blur', () => {
      (toCents as jest.Mock).mockReturnValueOnce(0);

      const { getByDisplayValue } = renderWithTheme(
        <MoneyInput value={5000} onValueChange={mockOnValueChange} />,
      );

      const input = getByDisplayValue('50,00');

      fireEvent.changeText(input, '');
      fireEvent(input, 'blur');

      expect(mockOnValueChange).toHaveBeenCalledWith(0);
    });

    test('handles invalid input on blur', () => {
      (toCents as jest.Mock).mockReturnValueOnce(0);

      const { getByDisplayValue } = renderWithTheme(
        <MoneyInput value={0} onValueChange={mockOnValueChange} />,
      );

      const input = getByDisplayValue('0,00');

      fireEvent.changeText(input, 'invalid');
      fireEvent(input, 'blur');

      expect(mockOnValueChange).toHaveBeenCalledWith(0);
    });
  });

  describe('disabled state', () => {
    test('input is disabled when disabled prop is true', () => {
      const { getByDisplayValue } = renderWithTheme(
        <MoneyInput value={10000} onValueChange={mockOnValueChange} disabled={true} />,
      );

      const input = getByDisplayValue('100,00');

      expect(input.props.editable).toBe(false);
    });

    test('input is enabled when disabled prop is false', () => {
      const { getByDisplayValue } = renderWithTheme(
        <MoneyInput value={10000} onValueChange={mockOnValueChange} disabled={false} />,
      );

      const input = getByDisplayValue('100,00');

      expect(input.props.editable).toBe(true);
    });

    test('input is enabled by default', () => {
      const { getByDisplayValue } = renderWithTheme(
        <MoneyInput value={10000} onValueChange={mockOnValueChange} />,
      );

      const input = getByDisplayValue('100,00');

      expect(input.props.editable).toBe(true);
    });
  });

  describe('accessibility', () => {
    test('uses default accessibility label', () => {
      const { getByLabelText } = renderWithTheme(
        <MoneyInput value={10000} onValueChange={mockOnValueChange} />,
      );

      expect(getByLabelText('Bedrag')).toBeTruthy();
    });

    test('uses custom accessibility label', () => {
      const { getByLabelText } = renderWithTheme(
        <MoneyInput
          value={10000}
          onValueChange={mockOnValueChange}
          accessibilityLabel="Salaris bedrag"
        />,
      );

      expect(getByLabelText('Salaris bedrag')).toBeTruthy();
    });

    test('euro prefix has accessibility label', () => {
      const { getByLabelText } = renderWithTheme(
        <MoneyInput value={10000} onValueChange={mockOnValueChange} />,
      );

      expect(getByLabelText('Euro-teken')).toBeTruthy();
    });
  });

  describe('keyboard type', () => {
    test('uses decimal-pad keyboard type', () => {
      const { getByDisplayValue } = renderWithTheme(
        <MoneyInput value={10000} onValueChange={mockOnValueChange} />,
      );

      const input = getByDisplayValue('100,00');

      expect(input.props.keyboardType).toBe('decimal-pad');
    });
  });

  describe('edge cases', () => {
    test('handles very large cent values', () => {
      const { getByDisplayValue } = renderWithTheme(
        <MoneyInput value={99999999} onValueChange={mockOnValueChange} />,
      );

      expect(formatCentsToDutch).toHaveBeenCalledWith(99999999);
      expect(getByDisplayValue('999999,99')).toBeTruthy();
    });

    test('handles rapid value changes', () => {
      const { rerender } = renderWithTheme(
        <MoneyInput value={1000} onValueChange={mockOnValueChange} />,
      );

      rerender(
        <TestWrapper>
          <MoneyInput value={2000} onValueChange={mockOnValueChange} />
        </TestWrapper>,
      );
      rerender(
        <TestWrapper>
          <MoneyInput value={3000} onValueChange={mockOnValueChange} />
        </TestWrapper>,
      );
      rerender(
        <TestWrapper>
          <MoneyInput value={4000} onValueChange={mockOnValueChange} />
        </TestWrapper>,
      );

      expect(formatCentsToDutch).toHaveBeenCalledWith(4000);
    });

    test('handles focus -> change -> blur cycle', () => {
      (toCents as jest.Mock).mockReturnValue(5000);

      const { getByDisplayValue } = renderWithTheme(
        <MoneyInput value={0} onValueChange={mockOnValueChange} />,
      );

      const input = getByDisplayValue('0,00');

      fireEvent(input, 'focus');
      fireEvent.changeText(input, '50,00');
      fireEvent(input, 'blur');

      expect(formatDutchValue).toHaveBeenCalled();
      expect(toCents).toHaveBeenCalled();
      expect(mockOnValueChange).toHaveBeenCalledWith(5000);
      expect(formatCentsToDutch).toHaveBeenCalledWith(5000);
    });
  });
});



===== FILE: src/ui/components/__tests__/FieldRenderer.test.tsx =====
import { render } from 'src/test-utils/render/renderers'
import { FieldRenderer } from '../FieldRenderer';

describe('FieldRenderer', () => {
    const mockValueProvider = {
      getValue: jest.fn((id: string) => `Waarde voor ${id}`),
    };
  
    it('renders the value from the provider correctly', () => {
      // Deze 'render' gebruikt nu automatisch de ThemeProvider uit providers.tsx
      const { getByText } = render(
        <FieldRenderer fieldId="test-field" valueProvider={mockValueProvider as any} />
      );
  
      expect(getByText('Waarde voor test-field')).toBeTruthy();
    });
  
    it('handles empty values gracefully', () => {
      const emptyProvider = { getValue: () => null };
      const { getByText } = render(
        <FieldRenderer fieldId="empty" valueProvider={emptyProvider as any} />
      );
  
      expect(getByText('')).toBeTruthy();
    });
  });


===== FILE: src/ui/components/__tests__/InputCounter.test.tsx =====
import React from 'react';
import { fireEvent, screen } from '@testing-library/react-native';
import { renderWithState } from 'src/test-utils/render/renderers';
import { InputCounter } from 'src/ui/components/fields/InputCounter';

describe('InputCounter Integrity', () => {
  const mockStateWriter = { updateField: jest.fn() };

  beforeEach(() => {
    mockStateWriter.updateField.mockClear();
  });

  test('zou de initiële waarde moeten tonen', async () => {
    renderWithState(
      <InputCounter fieldId="test-field" value={5} stateWriter={mockStateWriter} />
    );

    // We zoeken nu specifiek op de testID die we in de component hebben teruggezet
    const counterValue = screen.getByTestId('counter-value');
    expect(counterValue.props.children).toBe(5);
  });

  test('plus knop verhoogt de waarde via de stateWriter', () => {
    renderWithState(
      <InputCounter fieldId="test-field" value={5} stateWriter={mockStateWriter} />
    );

    const plusButton = screen.getByTestId('counter-increment');
    fireEvent.press(plusButton);

    expect(mockStateWriter.updateField).toHaveBeenCalledWith('test-field', 6);
  });

  test('min knop verlaagt de waarde via de stateWriter', () => {
    renderWithState(
      <InputCounter fieldId="test-field" value={5} stateWriter={mockStateWriter} />
    );

    const minusButton = screen.getByTestId('counter-decrement');
    fireEvent.press(minusButton);

    expect(mockStateWriter.updateField).toHaveBeenCalledWith('test-field', 4);
  });
});


===== FILE: src/ui/components/FinancialSummary.tsx =====
import * as React from 'react';
import { View, Text } from 'react-native';
import { useAppStyles } from '@ui/styles/useAppStyles';
import { formatCurrency } from '@app/orchestrators/types'; // Gebruik je nieuwe financiële grondwet

// Definieer een interface voor de data die de selector levert
interface FinancialSummaryData {
  totalIncomeCents: number;
  totalExpensesCents: number;
  netCents: number;
}

interface Props {
  data: FinancialSummaryData;
}

export const FinancialSummary: React.FC<Props> = ({ data }) => {
  const { styles, colors, Tokens } = useAppStyles();

  // We gebruiken de data direct uit de lades, omgezet naar Euro's voor display
  const incomeDisplay = formatCurrency(data.totalIncomeCents);
  const expensesDisplay = formatCurrency(data.totalExpensesCents);
  const netDisplay = formatCurrency(data.netCents);

  return (
    <View style={styles.summaryDetail}>
      <Text style={styles.pageTitle}>Financieel Overzicht</Text>

      {/* Totaal Inkomsten */}
      <View style={styles.summaryRow}>
        <Text style={styles.summaryLabel}>Totaal Inkomsten:</Text>
        <Text style={[styles.summaryValue, { color: colors.success, fontWeight: '700' }]}>
          {incomeDisplay}
        </Text>
      </View>

      {/* Totaal Uitgaven */}
      <View style={styles.summaryRow}>
        <Text style={styles.summaryLabel}>Totaal Uitgaven:</Text>
        <Text style={[styles.summaryValue, { color: colors.error, fontWeight: '700' }]}>
          {expensesDisplay}
        </Text>
      </View>

      {/* Netto resultaat */}
      <View style={styles.summaryRowTotal}>
        <Text style={styles.summaryLabelBold}>Netto resultaat:</Text>
        <Text style={styles.summaryValueBold}>{netDisplay}</Text>
      </View>

      <View style={{ height: Tokens.Space.md }} />
    </View>
  );
};



===== FILE: src/ui/components/fields/InputCounter.tsx =====
import React from 'react';
import { View, Text, TouchableOpacity } from 'react-native';
import type { ValueProvider, StateWriter } from '../../../domain';

export interface InputCounterProps {
  fieldId: string;
  valueProvider?: ValueProvider;
  stateWriter?: StateWriter;
  value?: number;
  testIdBase?: string; // Om de test weer te laten slagen
}

export const InputCounter: React.FC<InputCounterProps> = ({ 
  fieldId, 
  valueProvider, 
  stateWriter,
  value: propValue,
  testIdBase = 'counter'
}) => {
  // Logica blijft hetzelfde: we gebruiken de nieuwe domein-architectuur
  const displayValue = propValue !== undefined 
    ? propValue 
    : (valueProvider ? Number(valueProvider.getValue(fieldId)) : 0);

  const handleUpdate = (newValue: number) => {
    if (stateWriter) {
      stateWriter.updateField(fieldId, newValue);
    }
  };

  return (
    <View style={{ flexDirection: 'row', alignItems: 'center' }}>
      <TouchableOpacity 
        onPress={() => handleUpdate(displayValue - 1)}
        testID={`${testIdBase}-decrement`}
      >
        <Text style={{ fontSize: 25 }}> - </Text>
      </TouchableOpacity>

      <Text 
        style={{ marginHorizontal: 15 }}
        testID={`${testIdBase}-value`}
      >
        {displayValue}
      </Text>

      <TouchableOpacity 
        onPress={() => handleUpdate(displayValue + 1)}
        testID={`${testIdBase}-increment`}
      >
        <Text style={{ fontSize: 25 }}> + </Text>
      </TouchableOpacity>
    </View>
  );
};

export default InputCounter;


===== FILE: src/ui/components/fields/DateField.tsx =====
import { formatDate } from '@ui/helpers/dateFormatting';
import * as React from 'react';
import { Platform, View, Text, Pressable } from 'react-native';
import DateTimePicker, { DateTimePickerEvent } from '@react-native-community/datetimepicker';
import { useAppStyles } from '@ui/styles/useAppStyles';

type Props = {
  label: string;
  valueISO?: string; // canoniek: 'YYYY-MM-DD'
  onChangeISO: (iso: string | undefined) => void;
  minISO?: string; // default: '1920-01-01'
  maxISO?: string; // default: vandaag
  errorText?: string | null;
  accessibilityLabel?: string;
};

const isoToDate = (iso?: string): Date => {
  if (!iso) return new Date();
  const [y, m, d] = iso.split('-').map(Number);
  // UTC noon voorkomt dagverschuiving door tijdzones
  return new Date(Date.UTC(y, (m ?? 1) - 1, d ?? 1, 12, 0, 0));
};

const isoToday = (): string => {
  const now = new Date();
  const y = now.getFullYear();
  const m = String(now.getMonth() + 1).padStart(2, '0');
  const d = String(now.getDate()).padStart(2, '0');
  return `${y}-${m}-${d}`;
};

const dateToISO = (dt: Date): string => {
  // Niet toISOString(); dat geeft TZ issues. Formatteer zelf naar YYYY-MM-DD (UTC)
  const y = dt.getUTCFullYear();
  const m = String(dt.getUTCMonth() + 1).padStart(2, '0');
  const d = String(dt.getUTCDate()).padStart(2, '0');
  return `${y}-${m}-${d}`;
};

const DateField: React.FC<Props> = ({
  label,
  valueISO,
  onChangeISO,
  minISO = '1920-01-01',
  maxISO,
  errorText,
  accessibilityLabel,
}) => {
  const { styles, colors } = useAppStyles() as any;
  const [show, setShow] = React.useState(false);

  const max = maxISO ?? isoToday();
  const display = valueISO ? formatDate(valueISO, 'dd-mm-yyyy') : '';

  return (
    <View style={styles.fieldContainer}>
      <Text style={styles.fieldLabel}>{label}</Text>

      <Pressable
        onPress={() => setShow(true)}
        accessibilityRole="button"
        accessibilityLabel={accessibilityLabel ?? label}
        style={[styles.input, { justifyContent: 'center' }, errorText && styles.inputError]}
      >
        <Text style={{ color: display ? colors.textPrimary : colors.textSecondary }}>
          {display || 'DD-MM-YYYY'}
        </Text>
      </Pressable>

      {show && (
        <DateTimePicker
          mode="date"
          value={valueISO ? isoToDate(valueISO) : isoToDate(max)}
          minimumDate={isoToDate(minISO)}
          maximumDate={isoToDate(max)}
          display={Platform.OS === 'ios' ? 'spinner' : 'calendar'}
          onChange={(event: DateTimePickerEvent, date?: Date) => {
            if (Platform.OS === 'android') setShow(false);
            if (event.type === 'dismissed') return;
            if (!date) return;
            const iso = dateToISO(date);
            onChangeISO(iso);
          }}
        />
      )}

      {errorText && <Text style={styles.errorTextStyle}>{errorText}</Text>}
    </View>
  );
};

export default DateField;



===== FILE: src/ui/components/fields/index.ts =====
// src/ui/components/fields/index.ts

export * from './FormField';
export * from './ConditionalField';

// Input & Interactie componenten
export * from './ChipButton';
export * from './DateField';
export * from './InputCounter';
export * from './MoneyField';
export * from './MoneyInput';
export * from './ToggleSwitch';

// Als je later meer velden toevoegt, hoef je alleen hier een regel toe te voegen.



===== FILE: src/ui/components/fields/ToggleSwitch.tsx =====
import * as React from 'react';
import { View, TouchableOpacity, Text } from 'react-native';
import { useAppStyles } from '@ui/styles/useAppStyles';

export type ToggleSwitchProps = {
  value: boolean;
  onToggle: () => void;
  labelTrue?: string;
  labelFalse?: string;
  accessibilityLabel?: string;
};

const ToggleSwitch: React.FC<ToggleSwitchProps> = ({
  value,
  onToggle,
  labelTrue = 'Ja',
  labelFalse = 'Nee',
  accessibilityLabel,
}) => {
  const { styles, _colors } = useAppStyles() as any;

  return (
    <View style={styles.toggleWrapper}>
      <TouchableOpacity
        style={[styles.toggleButton, value ? styles.toggleActive : styles.toggleInactive]}
        onPress={onToggle}
        accessibilityRole="switch"
        accessibilityLabel={accessibilityLabel}
        accessibilityState={{ checked: value }}
      >
        <Text style={styles.toggleText}>{value ? labelTrue : labelFalse}</Text>
      </TouchableOpacity>
    </View>
  );
};

export default ToggleSwitch;



===== FILE: src/ui/components/fields/MoneyField.tsx =====
import * as React from 'react';
import { View, Text, TextInput } from 'react-native';

export interface MoneyFieldProps {
  label: string;
  amount: number; // We gebruiken 'amount' zoals geëist door de compiler in DailyInput
  onAmountChange: (val: number) => void;
  error?: string;
}

export const MoneyField: React.FC<MoneyFieldProps> = ({ label, amount, onAmountChange, error }) => {
  return (
    <View style={{ marginBottom: 15 }}>
      <Text style={{ fontWeight: '600', marginBottom: 5 }}>{label}</Text>
      <TextInput
        style={{
          borderWidth: 1,
          borderColor: error ? 'red' : '#ccc',
          padding: 12,
          borderRadius: 8,
          fontSize: 18,
        }}
        keyboardType="numeric"
        value={amount.toString()}
        onChangeText={(text) => {
          const num = parseFloat(text.replace(',', '.'));
          onAmountChange(isNaN(num) ? 0 : num);
        }}
        placeholder="0.00"
      />
      {error && <Text style={{ color: 'red', fontSize: 12 }}>{error}</Text>}
    </View>
  );
};
export default MoneyField;



===== FILE: src/ui/components/fields/MoneyInput.tsx =====
import * as React from 'react';
import { View, Text, TextInput } from 'react-native';
import { useAppStyles } from '@ui/styles/useAppStyles';
import { toCents, formatCentsToDutch, formatDutchValue } from '@app/orchestrators/types';

type MoneyInputProps = {
  value: number; // Bedrag in centen (altijd >= 0)
  onValueChange: (cents: number) => void;
  disabled?: boolean;
  placeholder?: string;
  accessibilityLabel?: string;
};

const MoneyInput: React.FC<MoneyInputProps> = ({
  value,
  onValueChange,
  disabled = false,
  placeholder = '',
  accessibilityLabel = 'Bedrag',
}) => {
  const { styles } = useAppStyles();

  // De lokale staat houdt de string vast die de gebruiker ziet
  const [localValue, setLocalValue] = React.useState<string>(formatCentsToDutch(value));

  // Sync lokale staat als de externe waarde (centen) wijzigt
  React.useEffect(() => {
    setLocalValue(formatCentsToDutch(value));
  }, [value]);

  // Bij focus: verwijder duizendtal-punten voor makkelijk bewerken
  const onFocus = () => setLocalValue(formatDutchValue(localValue));

  // Tijdens typen: saniteer direct (geen letters, geen minus)
  const onChangeText = (text: string) => setLocalValue(formatDutchValue(text));

  // Bij blur: bereken centen en formatteer naar NL-standaard
  const onBlur = () => {
    const cents = toCents(localValue);
    onValueChange(cents); // Emit positieve centen naar de state
    setLocalValue(formatCentsToDutch(cents)); // "On-blur formatting"
  };

  return (
    <View style={styles.inputMoneyRow}>
      {/* Vast, niet-bewerkbaar prefix  */}
      <Text style={styles.moneyPrefix} accessibilityLabel="Euro-teken">
        €
      </Text>

      <TextInput
        value={localValue}
        onChangeText={onChangeText}
        onFocus={onFocus}
        onBlur={onBlur}
        placeholder={placeholder}
        editable={!disabled}
        accessibilityLabel={accessibilityLabel}
        keyboardType="decimal-pad" // Forceert numeriek pad op mobile
        style={styles.moneyTextInput}
      />
    </View>
  );
};

export default MoneyInput;



===== FILE: src/ui/components/fields/FormField.tsx =====
import React from 'react';
import { View, Text, TextInput } from 'react-native';
import type { ValueProvider, StateWriter } from '@domain';
import { useAppStyles } from '@ui/styles/useAppStyles';

interface FormFieldProps {
  fieldId: string;
  valueProvider: ValueProvider;
  stateWriter: StateWriter;
  label: string;
}

export const FormField: React.FC<FormFieldProps> = ({
  fieldId,
  valueProvider,
  stateWriter,
  label,
}) => {
  const { styles } = useAppStyles();
  const value = valueProvider.getValue(fieldId as any);
  
  const handleChange = (newValue: string) => {
    stateWriter.updateField(fieldId as any, newValue);
  };
  
  return (
    <View style={styles.fieldContainer}>
      <Text style={styles.fieldLabel}>{label}</Text>
      <TextInput
        style={styles.input}
        value={String(value ?? '')} 
        onChangeText={handleChange}
        accessibilityLabel={label}
      />
    </View>
  );
};

export default FormField;


===== FILE: src/ui/components/fields/ChipButton.tsx =====
import * as React from 'react';
import { TouchableOpacity, Text } from 'react-native';
import { useAppStyles } from '@ui/styles/useAppStyles';

export type ChipButtonProps = {
  label: string;
  selected: boolean;
  error?: boolean;
  onPress: () => void;
  accessibilityLabel?: string;
};

const ChipButton: React.FC<ChipButtonProps> = ({
  label,
  selected,
  error,
  onPress,
  accessibilityLabel,
}) => {
  const { styles, _colors } = useAppStyles() as any;

  return (
    <TouchableOpacity
      style={[styles.chip, selected && styles.chipSelected, error && styles.chipError]}
      onPress={onPress}
      accessibilityRole="button"
      accessibilityLabel={accessibilityLabel ?? label}
      accessibilityState={{ selected }}
    >
      <Text style={[styles.chipText, selected && styles.chipTextSelected]}>{label}</Text>
    </TouchableOpacity>
  );
};

export default ChipButton;



===== FILE: src/ui/components/fields/ConditionalField.tsx =====
import React from 'react';
import type { ValueProvider } from '@domain';

interface ConditionalFieldProps {
  fieldId: string;
  valueProvider: ValueProvider;
  isVisible: boolean;
  children: React.ReactNode;
}

export const ConditionalField: React.FC<ConditionalFieldProps> = ({
  isVisible,
  children,
}) => {
  if (!isVisible) return null;
  return <>{children}</>;
};



