FASE 1 DOMMER MAKEN UI: Gebruik van datakeys en state.
======================
src/ui/components/FieldRenderer.tsx
import * as React from 'react';
import { FieldConfig, FormState, FormAction } from '@shared-types/form';
import FormField from '@fields/FormField';
import { evaluateVisibleIf } from '../../utils/fieldVisibility';

export interface FieldRendererProps {
  fields: FieldConfig[];
  state: FormState;
  dispatch: React.Dispatch<FormAction>;
}

export const FieldRenderer: React.FC<FieldRendererProps> = ({ fields, state, dispatch }) => {
  return (
    <>
      {fields.map((field) => {
        if (!evaluateVisibleIf(field.visibleIf, state)) {
          return null;
        }

        const section = (field.section ?? 'setup') as keyof FormState['data'];
        const value = (state.data[section] as Record<string, any>)[field.fieldId];

        return (
          <FormField
            key={field.fieldId}
            field={field}
            state={state}
            dispatch={dispatch}
            value={value}
          />
        );
      })}
    </>
  );
};

export default FieldRenderer;
====
src/ui/components/fields/ConditionalField.tsx
import * as React from 'react';
import { View } from 'react-native';
import { FieldConfig, FormState, FormAction } from '@shared-types/form';
import FormField from './FormField';
import { evaluateVisibleIf } from '../../../utils/fieldVisibility';

interface ConditionalFieldProps {
  field: FieldConfig;
  state: FormState;
  dispatch: React.Dispatch<FormAction>;
}

export const ConditionalField: React.FC<ConditionalFieldProps> = ({ field, state, dispatch }) => {
  // Gebruik de centrale util voor SSOT zichtbaarheid
  const isVisible = evaluateVisibleIf(field.visibleIf, state);

  if (!isVisible || !field.dependentField) {
    return null;
  }

  const dependentField = field.dependentField;
  const section = dependentField.section ?? 'setup';
  const fieldValue = (state.data[section] as any)[dependentField.fieldId];

  return (
    <View style={{ marginTop: 10, paddingLeft: 15, borderLeftWidth: 2, borderLeftColor: '#eee' }}>
      <FormField field={dependentField} state={state} dispatch={dispatch} value={fieldValue} />
    </View>
  );
};

export default ConditionalField;
====
src/ui/screens/CSV/CsvUploadScreen.tsx (optioneel â€“ data-extractie)
import { getISOWeek } from '@domain/helpers/DateHydrator';
import * as React from 'react';
import {
  View,
  Text,
  TouchableOpacity,
  ScrollView,
  TextInput,
  Alert,
  ActivityIndicator,
} from 'react-native';
import { useSafeAreaInsets } from 'react-native-safe-area-context';
import { dataOrchestrator } from '@services/dataOrchestrator';
import * as TransactionService from '@services/transactionService';
import { useAppStyles } from '@ui/styles/useAppStyles';
import { DATA_KEYS } from '@domain/constants/datakeys'; // Toegevoegd voor de juiste mapping
import { Logger } from '@/adapters/audit/AuditLoggerAdapter';

type Props = {
  onClose: () => void;
  // We verwachten nu de volledige household members en de setup
  members: any[];
  setupData: any;
};

const CsvUploadScreen: React.FC<Props> = ({ onClose, members, setupData }) => {
  const insets = useSafeAreaInsets();
  const { styles, colors } = useAppStyles();

  const [csvText, setCsvText] = React.useState('');
  const [isUploading, setIsUploading] = React.useState(false);

  const handleUpload = async () => {
    try {
      setIsUploading(true);

      // --- 1. DE NIEUWE WASSTRAAT (processAllData) ---
      // We geven de bestaande members mee voor de privacy mapping
      const result = dataOrchestrator.processAllData(members || [], csvText, setupData || {});

      // Gebruik de DATA_KEYS om de gefilterde lokale data op te halen

      const financeData = result.local[DATA_KEYS.FINANCE];

      if (financeData.transactions.length === 0) {
        Alert.alert('Fout', 'Geen geldige transacties gevonden. Controleer het formaat.');
        setIsUploading(false);
        return;
      }

      // --- 2. SAMENVATTING / SIGNALEN ---
      const { summary: income, hasMissingCosts } = financeData;

      let message =
        `${financeData.transactions.length} transacties verwerkt.\n\n` +
        `Inkomen bron: ${income.source}\n` +
        `Inkomen (centen): ${income.finalIncome}\n\n`;

      if (income.isDiscrepancy) {
        message +=
          `âš ï¸ We zien een afwijkend inkomen tussen CSV en Setup.\n` +
          `Verschil: formatCurrency(x)\n\n`;
      }

      if (hasMissingCosts) {
        message += `ðŸ  We vonden woonlasten in de CSV die niet in je setup stonden.\n\n`;
      }

      Alert.alert('Bevestig Upload', message + 'Wil je deze data opslaan?', [
        { text: 'Annuleren', style: 'cancel', onPress: () => setIsUploading(false) },
        {
          text: 'Opslaan',
          onPress: async () => {
            // --- 3. (ANONIEM) RESEARCH PAYLOAD NAAR ANALYTICS ---
            // Je kunt result.research direct doorsturen naar een API/n8n
            Logger.info('Sending to research:', result.research);

            // --- 4. OPSLAAN NAAR LOKALE STORAGE ---
            for (const tx of financeData.transactions) {
              await (TransactionService as any)._mockLocalSave({
                date: tx.date,
                amount: tx.amount,
                description: tx.description, // Al geanonimiseerd door orchestrator
                category: tx.category,
                paymentMethod: 'pin',
                weekNumber: getISOWeek(new Date(tx.date)),
              });
            }

            setIsUploading(false);
            Alert.alert('Succes', 'Je dashboard is bijgewerkt!', [
              { text: 'OK', onPress: onClose },
            ]);
          },
        },
      ]);
    } catch (e: any) {
      setIsUploading(false);
      Alert.alert('Fout', e?.message ?? 'Onbekende fout bij verwerken van CSV');
    }
  };

  return (
    <View style={styles.container}>
      <View style={styles.pageContainer}>
        <ScrollView
          contentContainerStyle={[styles.scrollContent, { paddingBottom: 120 + insets.bottom }]}
        >
          <Text style={styles.pageTitle}>Bankafschrift Importeren</Text>

          <Text style={{ color: colors.textSecondary, marginBottom: 16 }}>
            Plak hier je bank-export. Persoonsgegevens en IBANs worden automatisch geanonimiseerd.
          </Text>

          <TextInput
            style={[styles.input, { height: 240, textAlignVertical: 'top', fontFamily: 'Courier' }]}
            multiline
            placeholder="Plak hier uw CSV regels..."
            value={csvText}
            onChangeText={setCsvText}
            editable={!isUploading}
          />

          <TouchableOpacity
            style={[
              styles.button,
              {
                marginTop: 16,
                marginLeft: 0,
                backgroundColor: isUploading ? colors.secondary : colors.primary,
              },
            ]}
            onPress={handleUpload}
            disabled={isUploading || !csvText.trim()}
          >
            {isUploading ? (
              <ActivityIndicator color="#fff" />
            ) : (
              <Text style={styles.buttonText}>Analyseer CSV</Text>
            )}
          </TouchableOpacity>
        </ScrollView>
      </View>
    </View>
  );
};

export default CsvUploadScreen;
===
src/ui/screens/Wizard/pages/1setupHousehold.config.ts
// ADR-02: Type-Safety via relatieve paden
import { FormState, WizardPageConfig } from '@shared-types/form';
import { DATA_KEYS } from '@domain/constants/registry';
import { UX_TOKENS } from '@domain/constants/registry';

/**
 * ADR-04: UI Components zijn â€œdumbâ€.
 * De projector (WizardPage) haalt de teksten op via de tokens.
 */
export const setupHouseholdConfig: WizardPageConfig = {
  pageId: DATA_KEYS.SETUP,
  titleToken: UX_TOKENS.PAGES[DATA_KEYS.SETUP], // "Huishouden opzetten"
  componentName: 'WizardPage',
  fields: [
    {
      fieldId: 'aantalMensen', // De technische key in je state.data.setup
      label: 'Totaal aantal bewoners (N)', // Of gebruik: labelToken: UX_TOKENS.FIELDS.TOTAL_MEMBERS
      type: 'counter',
      defaultValue: 1,
      min: 1,
      max: 20,
    },
    {
      fieldId: 'aantalVolwassen',
      label: 'Aantal volwassenen (M)',
      type: 'counter',
      defaultValue: 1,
      min: 1,
      // ADR-01: Businesslogica in UI niet toegestaan, maar view-logic wel
      visibleIf: (state: FormState) => (state.data[DATA_KEYS.SETUP]?.aantalMensen || 0) > 0,
      maxGetter: (state: FormState) => state.data[DATA_KEYS.SETUP]?.aantalMensen || 1,
    },
    {
      fieldId: 'kinderenLabel',
      label: 'Waarvan aantal kinderen (K)',
      type: 'derived-label',
      // ADR-03: Berekening op basis van de state
      valueGetter: (state: FormState) => {
        const n = state.data[DATA_KEYS.SETUP]?.aantalMensen || 0;
        const m = state.data[DATA_KEYS.SETUP]?.aantalVolwassen || 0;
        return Math.max(0, n - m);
      },
      visibleIf: (state: FormState) => {
        const n = state.data[DATA_KEYS.SETUP]?.aantalMensen || 0;
        const m = state.data[DATA_KEYS.SETUP]?.aantalVolwassen || 0;
        return n > m;
      },
    },
    {
      fieldId: 'autoCount',
      labelToken: UX_TOKENS.FIELDS.CAR_COUNT, // Werkt nu!
      type: 'radio-chips',
      options: [
        { label: 'Geen', value: 'Nee' }, // Tip: gebruik 'Nee' ipv '0' als je visibleIf daarop checkt
        { label: '1 auto', value: 'Een' },
        { label: "2+ auto's", value: 'Twee' },
      ],
      defaultValue: 'Nee',
    },
    {
      fieldId: 'heeftHuisdieren',
      label: 'Zijn er huisdieren aanwezig?',
      type: 'toggle',
      defaultValue: false,
    },
  ],
};
====
src/ui/screens/Wizard/pages/2detailsHousehold.config.ts
import { DATA_KEYS, SUB_KEYS } from '@domain/constants/registry';
import { UX_TOKENS } from '@domain/constants/registry';
import { WizardPageConfig } from '@shared-types/wizard';

export const detailsHouseholdConfig: WizardPageConfig = {
  pageId: DATA_KEYS.HOUSEHOLD,
  titleToken: UX_TOKENS.PAGES[DATA_KEYS.HOUSEHOLD], // Automatisch 'Wie zijn de bewoners?'
  componentName: 'WizardPage',
  fields: [
    {
      fieldId: SUB_KEYS.MEMBERS,
      type: 'repeater',
      fields: [
        {
          fieldId: 'fullName',
          labelToken: UX_TOKENS.FIELDS.NAME, // 'Volledige naam'
          type: 'text',
          required: true,
        },
      ],
    },
  ],
};
====
src/ui/screens/Wizard/pages/3incomeDetails.config.ts
import { FormState } from '@shared-types/form';
import { WizardPageConfig } from '@shared-types/wizard';
import { DATA_KEYS, SUB_KEYS } from '@domain/constants/registry';
import { UX_TOKENS } from '@domain/constants/registry';

export const incomeDetailsConfig: WizardPageConfig = {
  // Gebruik de technische key voor consistentie
  pageId: '3incomeDetails',
  titleToken: UX_TOKENS.PAGES[DATA_KEYS.FINANCE], // Gebruikt "Inkomsten & lasten" uit labels.ts
  componentName: 'WizardPage',

  fields: [
    {
      // Dit zorgt dat de data onder state.data.finance.income terecht komt
      fieldId: SUB_KEYS.INCOME,
      label: 'Inkomen algemeen',
      type: 'section',
      fields: [
        {
          fieldId: 'work_salary',
          label: 'Inkomen uit werk (â‚¬/mnd)',
          type: 'money',
        },
      ],
    },
    {
      // De repeater die over de bewoners loopt
      fieldId: 'member_income_repeater',
      label: 'Inkomen per gezinslid',
      type: 'repeater',
      // ADR-03: Filter de leden uit het juiste state-pad
      filter: (state: FormState) => state.data[DATA_KEYS.HOUSEHOLD]?.members ?? [],
      fields: [
        {
          fieldId: 'member_income_details',
          type: 'section',
          label: 'Inkomensspecificatie',
          // Zorg dat we alleen iets tonen als er een memberId is (voor de context)
          visibleIf: (state: FormState, context?: { memberId?: string }) => !!context?.memberId,
          fields: [
            {
              fieldId: 'salary',
              label: 'Salaris (â‚¬/mnd)',
              type: 'money',
            },
            {
              fieldId: 'benefits',
              label: 'Uitkering/Toeslagen (â‚¬/mnd)',
              type: 'money',
            },
          ],
        },
      ],
    },
  ],
};
====
src/ui/screens/Wizard/pages/4fixedExpenses.config.ts
import { FormState } from '@shared-types/form';
import { WizardPageConfig } from '@shared-types/wizard';
import { DATA_KEYS, SUB_KEYS } from '@domain/constants/registry';
import { UX_TOKENS } from '@domain/constants/registry';

export const fixedExpensesConfig: WizardPageConfig = {
  pageId: '4fixedExpenses',
  titleToken: UX_TOKENS.PAGES[DATA_KEYS.FINANCE], // Gebruikt de 'Inkomsten & lasten' token
  componentName: 'WizardPage',
  fields: [
    {
      // We nesten dit onder EXPENSES voor de orchestrator
      fieldId: SUB_KEYS.EXPENSES,
      label: 'Wonen',
      type: 'section',
      fields: [
        {
          fieldId: 'living_costs',
          label: 'Huur / Hypotheek (â‚¬/mnd)',
          type: 'money',
        },
      ],
    },
    {
      fieldId: 'car_repeater',
      label: 'Vervoer (Auto)',
      type: 'repeater',
      // ADR-01: View-logic gebaseerd op de SETUP state
      visibleIf: (state: FormState) => state.data[DATA_KEYS.SETUP]?.autoCount !== 'Nee',

      // ADR-03: De repeater lengte wordt bepaald door de eerdere keuze
      countGetter: (state: FormState) => {
        const val = state.data[DATA_KEYS.SETUP]?.autoCount;
        if (val === 'Een') return 1;
        if (val === 'Twee') return 2;
        return 0;
      },
      fields: [
        { fieldId: 'car_fixed', label: 'Verzekering + Belasting', type: 'money' },
        { fieldId: 'car_fuel', label: 'Brandstof / Laden', type: 'money' },
      ],
    },
    {
      fieldId: 'subscription_section',
      label: 'Streaming & Abonnementen',
      type: 'collapsible-section',
      fields: [
        { fieldId: 'netflix', label: 'Netflix', type: 'money' },
        { fieldId: 'videoland', label: 'Videoland', type: 'money' },
        { fieldId: 'hbo', label: 'HBO Max', type: 'money' },
        { fieldId: 'disneyPlus', label: 'Disney+', type: 'money' },
      ],
    },
  ],
};
====
src/ui/screens/Wizard/WizardPage.tsx
import * as React from 'react';
import { View, Text, ScrollView, StyleSheet } from 'react-native';
import { useForm } from '@app/context/FormContext';
import FormField from '@components/fields/FormField';
import { WizardPageConfig, DataSection } from '@shared-types/form';
import { evaluateVisibleIf } from '../../../utils/fieldVisibility';

interface WizardPageProps {
  config: WizardPageConfig;
  onNext: () => void;
  onBack: () => void;
  isFirst: boolean;
  isLast: boolean;
}

export const WizardPage: React.FC<WizardPageProps> = ({ config }) => {
  const { state, dispatch } = useForm();

  return (
    <View style={styles.container}>
      {config.titleToken && <Text style={styles.title}>{config.titleToken}</Text>}
      {config.title && <Text style={styles.title}>{config.title}</Text>}

      <ScrollView style={styles.scrollContainer}>
        {config.fields.map((field) => {
          const targetSection: DataSection = field.section || config.section || 'setup';
          const sectionData = state.data[targetSection];
          const value = (sectionData as any)?.[field.fieldId];

          // Gebruik de centrale util voor SSOT zichtbaarheid
          if (!evaluateVisibleIf(field.visibleIf, state)) {
            return null;
          }

          return (
            <FormField
              key={field.fieldId}
              field={field}
              state={state}
              dispatch={dispatch}
              value={value}
            />
          );
        })}
      </ScrollView>
    </View>
  );
};

const styles = StyleSheet.create({
  container: { flex: 1, padding: 16 },
  title: { fontSize: 24, fontWeight: 'bold', marginBottom: 16 },
  scrollContainer: { flex: 1 },
});